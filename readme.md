Blok
====

Building blocks for UI

About
-----

Blok is a UI framework for Haxe designed to be simple and free of dependencies or DSLs. Everything is written in normal Haxe, with just a little macro magic to make things simpler.

Packages
--------

Packages will be split out eventually, but they're all in one place for now (for ease of development and because I'm not sure what works best yet).

- [blok.core](packages/core): The base implementation used everywhere.
- [blok.core.style](packages/core.style): Blok's (optional) style system.
- [blok.core.html](packages/core.html): Blok's HTML implementation (used by the DOM and Static platforms).
- [blok.platform.dom](packages/platform.dom): Implementation for browsers.
- [blok.platform.static](packages/platform.static): Static HTML rendering.
- [blok.platform.h2d](packages/platform.h2d): Implementation for heaps (currently not up to date).

Getting Started
---------------

Blok is in too much flux for a good tutorial to be viable. Check out the [example](example) folder to see the library in use for the time being. The [todomvc](example/todomvc/Main.hx) example is fairly comprehensible and documented.

Frankly you shouldn't use this yet anyway!

If you _are_ interested, however, the way to make this work is to:
- Clone this repo somewhere
- Using [Lix](https://github.com/lix-pm), manually create a file for each of the blok packages you need in the [haxe_libaries](haxe_libraries) folder. This repository actually uses that method -- take a look there to get an idea of what to do.

This is obviously _not_ useful for anything but playing around. Use at your own risk.

Components
----------

> This section is mostly here to ensure I don't forget the features
> I've implemented.

Components in Blok work much like they do in React/Preact/etc., with a bit of inspiration from Flutter.

You'll probably never create a Component directly -- instead, you'll use the `{ComponentName}.node({ ... })` static method (generated by macro for each Component) which returns a VNode.

### Props

All fields marked with `@prop` will be added to the Component's constructor.

```haxe
using Blok;

class Example extends Component {
  @prop var foo:String; // required
  @prop var bar:String = 'bar'; // optional, as a default value exists.
}
```

### Lifecycle

There are three lifecycle hooks in Blok: `@init`, `@dispose` and `@effect`. `@init` methods will be run once when the Component is created, `@dispose` is run when the Component is removed, and `@effect` is run after a component is rendered.

```haxe
using Blok;

class Example extends Component {
  
  /* ... */

  @init
  function setup() {
    trace('Setup');
  }

  @dispose
  function teardown() {
    trace('teardown');
  }

  @effect
  function onChange() {
    trace('changed');
  }
}
```

### State

The state of a Component can be updated using `@update` methods. This is somewhat discouraged in favor of using `blok.State` classes.

`@update` methods are run through a macro that expects an [UpdateMessage](packages/core/blok/core/UpdateMessage.hx) to be returned.

```haxe
using Blok;

class Example extends Component {
 
  /* ... */

  @update
  public function setFoo(foo:String) {
    if (this.foo == foo) return None;
    return UpdateState({
      foo: foo
    });
  }

  @update
  public function setFooAndBar(foo:String, bar:String) {
    return UpdateState({
      foo: foo,
      bar: bar
    });
  }
}
```

### Rendering

The `render` method is what actually displays something. It must return a `VNode` *or* `null`.

```haxe
using Blok;

class Example extends Component {
 
  /* ... */

  override function render(context:Context) {
    return Html.div({
      children: [
        Html.text('${foo} ${bar}'),
        Html.button({
          attrs: {
            onclick: e -> {
              setFooAndBar('bin', 'bax');
            }
          },
          children: [ Html.text('Change') ]
        })
      ]
    });
  }
}

```

### Observable

In some cases you might want to only change a part of a Component. This could be done with another component, but you can also use [Observables](packages/core/blok/core/Observable.hx).


```haxe
using Blok;

class ObservableExample extends Component {
  var foo:Observable<String> = new Observable('foo');

  @dispose
  function cleanupFoo() {
    foo.dispose(); // Always dispose your observables!
  }

  override function render(context:Context) {
    return Html.div({
      children: [
        foo.mapToVNode(value -> Html.text(value)),
        Html.button({
          attrs: {
            onclick: e -> {
              foo.notify('bar')
            }
          },
          children: [ Html.text('Change') ]
        })
      ]
    });
  }
}
```

Components also have an `@observable` macro that takes care of initialization and teardown for you. This will also add the `@observable` field to the constructor, meaning you can initialize it like a `@prop`.

> I'm not sure if this is good behavior or not, so this might change.

```haxe
using Blok;

class ObservableExample extends Component {
  @observable var foo:String = 'foo';

  override function render(context:Context) {
    return Html.div({
      children: [
        foo.mapToVNode(value -> Html.text(value)),
        Html.button({
          attrs: {
            onclick: e -> {
              foo.notify('bar')
            }
          },
          children: [ Html.text('Change') ]
        })
      ]
    });
  }
}
```

States
------

> Todo
